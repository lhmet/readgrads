#' Dumps subsets of grads data into a data.frame
#' 
#' This funcion takes the output of \code{\link{readGradsFile}} and
#' converts it to a data.frame. The function allows the user to 
#' take subsets in terms of timesteps, variables and levels.
#' 
#' @param ts numeric vector giving the timesteps which are to be included, e.g. 1:100.
#' @param lev numeric vector expressing which levels are to be included, e.g. lev = c(200, 500).
#' @param var character vector expressing which variable(s) are to be included, e.g. var = "psi".
#' @param gradsData the grads data, object is generated by \code{\link{readGradsFile}}.
#' @param ctlparams the parameters of the grads data, object is generated by \code{\link{parseCTLfile}}.
#' @param correctionFactor the values read from the grads files are multiplied by this number.
#' @return something
#' @author Paul Hiemstra, \email{p.h.hiemstra@@gmail.com}
#' @export
#' @examples
#' data(ctlparams)
#' data(gradsExampleData)
#' 
#' dat1 = subsetGradsData(1, 500, "u", gradsExampleData, ctlparams)
#' dat2 = subsetGradsData(1:2, 200, c("u","v"), gradsExampleData, ctlparams)
#' dat3 = subsetGradsData(1:2, 800, "psi", gradsExampleData, ctlparams)
subsetGradsData <-
function(ts, lev, var, gradsData, ctlparams, correctionFactor = 1) {
  gridsize = ctlparams$xdef$noLevels * ctlparams$ydef$noLevels
  whichDataIsNeeded = .mapGradsDataIndexToMetadata(ts, lev, var, ctlparams)
  indexes = format(whichDataIsNeeded$indicies, scientific = FALSE, trim = TRUE)

  dat = gradsData[indexes]
  names(dat) = indexes
  out = melt(lapply(dat, function(x) {
    return(data.frame(.getXYcoordinates(ctlparams), x))
#     return(subset(dum, level %in% lev & variable %in% var))
  }), measure.vars = NULL)
  names(out)[4] <- "index"
  out$value = correctionFactor * out$value
  if(length(var) == 1) {
    names(out)[names(out) == "value"] <- var
  }
  out$index = as.numeric(out$index)
  out = data.frame(out, whichDataIsNeeded$metadata[as.character(out$index),])
  return(out)
}

