#' Dumps subsets of grads data into a data.frame
#' 
#' This funcion takes the output of \code{\link{readGradsFile}} and
#' converts it to an array. The function allows the user to 
#' take subsets in terms of timesteps, variables and levels.
#' 
#' @param ts numeric vector giving the timesteps which are to be included, e.g. 1:100.
#' @param lev numeric vector expressing which levels are to be included, e.g. lev = c(200, 500).
#' @param var character vector expressing which variable(s) are to be included, e.g. var = "psi".
#'            Note that there is currently no support for converting more than one var at a time.
#' @param gradsData the grads data, object is generated by \code{\link{readGradsFile}}.
#' @param ctlparams the parameters of the grads data, object is generated by \code{\link{parseCTLfile}}.
#' @return a multi-dimensional array with the requested subset.
#' @author Paul Hiemstra, \email{p.h.hiemstra@@gmail.com}
#' @export
#' @examples
#' data(ctlparams)
#' data(gradsExampleData)
#' 
#' dat1 = gradsData2array(1, 500, "u", gradsExampleData, ctlparams)
#' dat2 = gradsData2array(1:2, 200, c("u"), gradsExampleData, ctlparams)
#' dat3 = gradsData2array(1:2, 800, "psi", gradsExampleData, ctlparams)
gradsData2array <-
function(ts, lev, var, gradsData, ctlparams) {
  whichDataIsNeeded = .mapGradsDataIndexToMetadata(ts, lev, var, ctlparams)
  out = array(dim = c(ctlparams$xdef$noLevels, ctlparams$ydef$noLevels, length(lev), length(ts)))
  dimnames(out) = list(xcoor = ctlparams$xdef$levelValues, ycoor = ctlparams$ydef$levelValues, level = lev, tstep = ts)
  for(i in seq_len(nrow(whichDataIsNeeded$metadata))) {
    x = whichDataIsNeeded$metadata[i,]
    idx = as.numeric(rownames(x))
    out[,,as.character(x$level),as.character(x$tstep)] <- matrix(as.matrix(gradsData[[as.character(idx)]]), ctlparams$xdef$noLevels,ctlparams$ydef$noLevels)
  }
  return(out)
}

